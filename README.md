# plgn_db

Здесь пока представлен только клиент для этого задания.

Порты, используемые для работы: 5555 и 5556.

Запуск клиента: client:main(). 

Также здесь есть 2 простеньких сервера для теста: REP и PUB.

Запускаются: rep_server:main()  и publisher:main().

rep_server на все запросы от клиента отвечает рандомно ok или error.

publisher каждые 10 секунд  шлет сообщение из 3х слов первое: <Таблица>(название таблицы) 2е: рандомно <0> или <1> (база обновлена или удалена) 

3е: рандомное число (означающе имя ключа).

Для теста клиента этого достаточно.

--------------------------------------------------------------------------------------------------------------------------------------------

Необходимо создать сервис, представляющий собой Key-Value базу данных.

Ключи и значения могут являться совершенно абстрактыми данными.

У элементов БД может быть назначено "время жизни", по истечению которого элемент будет удаляться из БД.

БД должна обладать следующим функционалом:

- Создание таблиц
- Удаление таблиц
- Добавление/изменение элементов
- Удаление элементов
- Поиск элементов
  
Также БД должна отправлять уведомления об изменении элементов.

Исходный код должен быть представлен в виде форка данного репозитория.

Репозиторий должен содержать исходный код решения, тесты, необходимое описание для запуска.

Язык для реализации может быть любым из: C/C++/Python/Erlang.

# Техническая часть

Взаимодействие с БД должно происходить по ZMTP (соответственно желательно использовать библиотеку ZMQ).

Понадобиться как минимум 2 сокета:

- REP-сокет, служит для входящих соединений к БД
- PUB-сокет, служит для отправки уведомлений

Необходима поддержка нескольких одновременных подключений к БД.

Все операции над элементами БД должны быть атомарными.

# Описание протокола взаимодействия с БД

Взаимодействия с БД осуществляется через отправку ZMQ сообщений, состоящих из нескольких фреймов.

Первый фрейм это код команды. Последущие фреймы это аргументы команд.

В ответ на команды БД должна отправлять статус запроса (также ZMQ сообщение, состоящее из нескольких фреймов).

Необходимые команды и их структура:

| Синтаксис сообщений команд | Синтаксис сообщений ответа |
| --- | --- |
| `{CREATE_TABLE <TAB_NAME>}` | `{OK} \| {ERROR <REASON>}` |
| `{DELETE_TABLE <TAB_NAME>}` | `{OK} \| {ERROR <REASON>}` |
| `UPDATE <TAB_NAME> <KEY> <VALUE> [<TTL_SEC>]` | `{OK} \| {ERROR <REASON>}` |
| `DELETE <TAB_NAME> <KEY>` | `{OK <VALUE>} \| {ERROR <REASON>}` |
| `GET <TAB_NAME> <KEY>` | `{OK <VALUE>} \| {ERROR <REASON>}` |

Где:

- `CREATE_TABLE`, `DELETE_TABLE`, `UPDATE`, `DELETE`, `GET` - целые беззнаковые числа размером 1 байт (0, 1, 2, 3, 4 соответственно)
- `<TAB_NAME>` - строка до 255 байт (с учетом символа конца строки)
- `<KEY>`, `<VALUE>` - любые бинарные данные, ключ имеет ограничение на 64 байт, данные - 1 килобайт
- `<TTL_SEC>` - опциональный параметр, может отсутствовать. Целое беззнаковые число размером 64 байт - количество секунд

> **Замечание**: при обновлении данных, если не указан параметр TTL, TTL остается прежним. Если при добавлении TTL не был указан, то данные хранятся в таблице пока не будут удалены, или пока им не будет назначен TTL.

Структура сообщений уведомлений:

- `<TAB_NAME> UPDATED <KEY>`
- `<TAB_NAME> DELETED <KEY>`

Где:

- `UPDATED`, `DELETED` - целые беззнаковые числа размером 1 байт (0, 1 соответственно)
- `<TAB_NAME>` - строка до 255 байт (с учетом символа конца строки)
- `<KEY>` - любые бинарные данные, ключ имеет ограничение на 64 байт
